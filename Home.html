<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>Sorting</h1>
    <pre><code>
 
class Sorting {
    static let list = [64, 25, 12, 22, 11]
}

extension Sorting {
    /*
      * Find the smallest element and swap it with the first.
      * Repeat the same for the remaining list
      * This problem can be solved with 2 loops or recursion
      -- Here we solve by recursion---
     */
    class func selectionSort(arr: [Int] = Sorting.list, fromIndx: Int = 0) -> [Int] {
        guard arr.count-1 > fromIndx else { return arr }
       
        var mList = arr
        var smallestI = fromIndx
        for i in fromIndx..<mList.count {
            if mList[smallestI] > mList[i] {
                smallestI = i
            }
        }
        if smallestI != fromIndx {
            let temp = mList[fromIndx]
            mList[fromIndx] = mList[smallestI]
            mList[smallestI] = temp
        }
        return selectionSort(arr: mList, fromIndx: fromIndx+1)
    }
}


extension Sorting {
    /*
     * Worst sorting technique
     * Maximum number of comparisons and swaps
     * Comopare the element with their next and if found irrelevant [greater in case of ascending], do swap
     * Repeat the above step till last-1 element
     */
    class func bubbleSort(arr: [Int] = Sorting.list) -> [Int] {
        guard arr.count > 1 else { return arr }
        var aList = arr
        
        let n = aList.count
        for i in 0..<aList.count {
            for j in 0..<(n-i-1) {
                if aList[j]>aList[j+1] { // swap
                    let temp = aList[j]
                    aList[j] = aList[j+1]
                    aList[j+1] = temp
                }
            }
        }
        return aList
    }
}
    </code></pre>
</body>
</html>
